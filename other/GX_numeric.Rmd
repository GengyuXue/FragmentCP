---
title: "GX_numeric"
output: html_document
date: "2024-04-03"
---
```{r}
lambda = 0.00001
# lambda = 0.0001
# lambda = 0
ext = 0.1
maxIt = 1
r1 = 3
r2 = 3
sigma1 = 1
sigma2 = 1
Delta = 50
regular_grid = seq(0.05, 0.95, length.out = 50)
```

Simulate data: 
```{r}
data1 = temp_fragment_data7(mu = 0, r = r1, sigma1, n = 150, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data2 = temp_fragment_data9(mu = 0, r = r2, sigma2, n = 150, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data = list("t"= rbind(data1$t, data2$t), "y" = rbind(data1$y, data2$y), "r" = cbind(data1$r, data2$r))
```

Estimatoin (data1 using temp_fragment_data6):
```{r}
cov.obj1 = cov_basis(data1$t, data1$y, data1$r, r1, lambda, ext, maxIt) # estimate covariance function
C_est1 <- cov.obj1$C
C_est1
cov_est1 = predict_cov(regular_grid, C_est1)
cov.obj1$error
# obtain the true covariance function
# dist_mat = dist(1:r1, method = "manhattan", diag = T, upper = T)

C_1 = matrix(0, nrow = r1, ncol = r1)
diag(C_1) = seq(from = 20, by = -6, length.out = r1)

# C_1 <-  matrix(0, nrow = r1, ncol = r1)
# diag(C_1) <- (1:r1)^(-1)

#C_1 <- as.matrix(2^(-dist_mat - 5/2)) + diag(1.5^(1-(1:r1)))
C_1
cov1 = predict_cov(regular_grid, C_1)
# compare
mean((cov_est1 - cov1)^2)
```


Estimation (data2 using  temp_fragment_data5):
```{r}
cov.obj2 = cov_basis(data2$t, data2$y, data2$r, r2, lambda, ext, maxIt)
C_est2 <- cov.obj2$C
C_est2
cov.obj2$error
cov_est2 = predict_cov(regular_grid, C_est2)
C_2 = matrix(0, nrow = r, ncol = r)
diag(C_2) = seq(from = 30, by = -8, length.out = r)
C_2
cov2 = predict_cov(regular_grid, C_2)
mean((cov_est2 - cov2)^2)
#sum((cov_est2 - cov2)^2)/sum(cov2^2)
```


Estimation (data 1 using temp_fragment_data7):
```{r}
cov.obj1 = cov_basis(data1$t, data1$y, data1$r, r1, lambda, ext, maxIt) # estimate covariance function
C_est1 <- cov.obj1$C
C_est1
cov_est1 = predict_cov(regular_grid, C_est1)
cov.obj1$error

C_1 = matrix(0, nrow = r1, ncol = r1)
diag(C_1) = seq(from = 2, by = -0.6, length.out = r1)
C_1
cov1 = predict_cov(regular_grid, C_1)
# compare
mean((cov_est1 - cov1)^2)
```

Estimation (data 2 using temp_fragment_data8):
```{r}
cov.obj2 = cov_basis(data2$t, data2$y, data2$r, r2, lambda, ext, maxIt)
C_est2 <- cov.obj2$C
C_est2
cov.obj2$error
cov_est2 = predict_cov(regular_grid, C_est2)
C_2 = matrix(0, nrow = r, ncol = r)
diag(C_2) = c(0,seq(from = 2, by = -0.6, length.out = r-1))
C_2
cov2 = predict_cov(regular_grid, C_2)
mean((cov_est2 - cov2)^2)
```



Jump size:
```{r}
mean((cov1 - cov2)^2)
mean((cov_est1 - cov_est2)^2)
```


Using both data:
```{r}
cov.obj = cov_basis(data$t, data$y, data$r, r1, lambda, ext, maxIt)
C_est <- cov.obj$C
cov.obj$error
cov_est = predict_cov(regular_grid, C_est, ext)
mean((cov_est - cov1)^2)
mean((cov_est - cov2)^2)
mean((cov_est - (cov1+cov2)/2)^2)
```

Using part of the data:
```{r}
cov.obj_whole <- cov_basis(data$t, data$y, data$r, r1, lambda, ext, maxIt)
cov.obj_first <- cov_basis(data$t[1:100,], data$y[1:100,], data$r[,1:3000], r1, lambda, ext, maxIt)
cov.obj_second <- cov_basis(data$t[101:200,], data$y[101:200,], data$r[, 3001:6000], r1, lambda, ext, maxIt)

cov.obj_whole$error - cov.obj_first$error - cov.obj_second$error

cov.obj_whole <- cov_basis(data$t[101:200,], data$y[101:200,], data$r[ ,3001:6000], r1, lambda, ext, maxIt)
cov.obj_first <- cov_basis(data$t[101:150,], data$y[101:150,], data$r[ ,3001:4500], r1, lambda, ext, maxIt)
cov.obj_second <- cov_basis(data$t[151:200,], data$y[151:100,], data$r[, 4501:6000], r1, lambda, ext, maxIt)

cov.obj_whole$error
cov.obj_first$error
cov.obj_second$error


cov.obj_whole$C
cov.obj_first$C
cov.obj_second$C

C_est <- cov.obj$C
cov_est = predict_cov(regular_grid, C_est, ext)
mean((cov_est - cov1)^2)
mean((cov_est - cov2)^2)
mean((cov_est - (cov1+cov2)/2)^2)
```

```{r}
lambda = 0.001
cov.obj_whole <-  cov_basis(data$t, data$y, data$r, r1, lambda, ext, maxIt)
cov.obj_first <- cov_basis(data$t[1:18,], data$y[1:18,], data$r[,1:540], r1, lambda, ext, maxIt)
cov.obj_second <- cov_basis(data$t[19:200,], data$y[19:200,], data$r[, 541:6000], r1, lambda, ext, maxIt)
cov.obj_whole$error -  275.3107234 - cov.obj_second$error
cov.obj_whole$C
```

```{r}
lambda = 0.00001
cov.obj_whole <-  cov_basis(data$t[1:18,], data$y[1:18,], data$r[,1:540], r1, lambda, ext, maxIt)
cov.obj_first <- cov_basis(data$t[1:16,], data$y[1:16,], data$r[,1:480], r1, lambda, ext, maxIt)
cov.obj_second <- cov_basis(data$t[17:18,], data$y[17:18,], data$r[, 481:540], r1, lambda, ext, maxIt)
cov.obj_first$error + cov.obj_second$error +130
```




```{r}
lambda = 0.00001
# lambda = 0.0001
# lambda = 0
ext = 0.1
maxIt = 1
r1 = 2
r2 = 3
sigma1 = 1
sigma2 = 5
Delta = 50
regular_grid = seq(0.05, 0.95, length.out = 50)
data1 = temp_fragment_data11(mu = 0, sigma1, n = 100, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data2 = temp_fragment_data12(mu = 0, sigma2, n = 100, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data = list("t"= rbind(data1$t, data2$t), "y" = rbind(data1$y, data2$y), "r" = cbind(data1$r, data2$r))
```

Change point:
```{r}
cpt_result = DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi = 1000, ext, maxIt, Delta=0)
# cpt_result = DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi = 35000, ext, maxIt, Delta=1)
cpt_result$partition
cpt_result$bestvalue
part2local(cpt_result$partition)
```

CV:
```{r}
# xi_set = c(2100, 2200, 2300, 2500, 2700)
xi_set = c(3500, 4000, 4500, 5000 )
CV_cpt_result = CV_search_DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi_set, ext, maxIt)
min_idx = which.min(CV_cpt_result$test_error) 
xi_set[min_idx]
cpt_init = unlist(CV_cpt_result$cpt_hat[min_idx])
cpt_init
```





Case with two change points(7,9,10):
```{r}
lambda = 0.00001
# lambda = 0.0001
# lambda = 0
ext = 0.1
maxIt = 1
r1 = 3
r2 = 3
sigma1 = 1
sigma2 = 1
Delta = 50
regular_grid = seq(0.05, 0.95, length.out = 50)
```

Simulate data: 
```{r}
data1 = temp_fragment_data7(mu = 0, r = r1, sigma1, n = 100, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data2 = temp_fragment_data9(mu = 0, r = r2, sigma2, n = 100, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data3 = temp_fragment_data10(mu = 0, r = r2, sigma2, n = 100, m = 30, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data = list("t"= rbind(data1$t, data2$t, data3$t), "y" = rbind(data1$y, data2$y, data3$y), "r" = cbind(data1$r, data2$r, data3$r))
```

Change point:
```{r}
cpt_result = DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi = 1000, ext, maxIt, Delta=0)
# cpt_result = DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi = 35000, ext, maxIt, Delta=1)
cpt_result$partition
cpt_result$bestvalue
part2local(cpt_result$partition)
```

```{r}
# xi_set = c(900, 1000, 1100, 1200, 1300, 1400, 1500, 1600)
# xi_set = c(700, 800, 900)
xi_set = c(350, 400, 500, 600, 700, 800)
CV_cpt_result = CV_search_DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi_set, ext, maxIt)
min_idx = which.min(CV_cpt_result$test_error) 
xi_set[min_idx]
cpt_init = unlist(CV_cpt_result$cpt_hat[min_idx])
cpt_init
```


```{r}
r=3
zeta_set = c(700, 800, 900, 1000, 1100)
CV_SBS_result = CV_search_SBS_fragment(data$t, data$y, data$r, r, lambda, ext, maxIt, zeta_set, Delta = 20)
min_idx = which.min(CV_SBS_result$test_error) 
zeta_set[min_idx]
cpt_init = unlist(CV_SBS_result$cpt_hat[min_idx])
cpt_init
```





```{r}
##TO DO
RR = 200
alpha = 0.01
index_remove = which(len_rkhs_init_vec != length(cpt_true))
sum(len_rkhs_init_vec[index_remove] < 1)/RR
sum(len_rkhs_init_vec[index_remove] > 1)/RR
if(length(index_remove)==0){
  cpt_rkhs_init_new = do.call(rbind, cpt_rkhs_init_list)
  cpt_rkhs_LR_new = do.call(rbind, cpt_rkhs_LR_list)
  beta_rkhs_list_new = beta_rkhs_list
  y_list_new = y_list
  x_list_new = x_list
}else{
  cpt_rkhs_init_new = do.call(rbind, cpt_rkhs_init_list[-index_remove])
  cpt_rkhs_LR_new = do.call(rbind, cpt_rkhs_LR_list[-index_remove])
  beta_rkhs_list_new = beta_rkhs_list[-index_remove]
  y_list_new = y_list[-index_remove]
  x_list_new = x_list[-index_remove]
}
LRV_rkhs_hat_mat = matrix(NA, nrow = nrow(cpt_rkhs_init_new), ncol = length(cpt_true))
kappa2_rkhs_hat_mat = matrix(NA, nrow = nrow(cpt_rkhs_init_new), ncol = length(cpt_true))
drift_rkhs_hat_mat = matrix(NA, nrow = nrow(cpt_rkhs_init_new), ncol = length(cpt_true))
B = 1000
u_array = array(NA, c(nrow(cpt_rkhs_init_new), length(cpt_true), B))
CI_array = array(NA, c(nrow(cpt_rkhs_init_new), length(cpt_true), 2))
for(i in 1:nrow(cpt_rkhs_init_new)){
  y_vec = y_list_new[[i]]
  x_mat = x_list_new[[i]]
  interval_refine = trim_interval(n = length(y_vec), cpt_rkhs_init_new[i,], w = 0.9)
  block_size = ceiling((min(floor(interval_refine[,2]) - ceiling(interval_refine[,1])))^(2/5)/2) # choose S
  print(block_size)
  temp = LRV.rkhs(cpt_rkhs_init_new[i,], beta_rkhs_list_new[[i]], y_vec, x_mat, w = 0.9, block_size)
  LRV_rkhs_hat_mat[i,] = temp$lrv_hat
  kappa2_rkhs_hat_mat[i,] = temp$kappa2_hat
  #drift_hat_mat[i,] = sapply(1:nrow(interval_refine), function(x) t(beta_list_new[[i]][,x+1] - beta_list_new[[i]][,x]) %*% (t(cbind(rep(1,dim(data$X)[1]), data$X))%*%cbind(rep(1,dim(data$X)[1]), data$X)) %*% (beta_list_new[[i]][,x+1] - beta_list_new[[i]][,x]) / (n*kappa2_hat_mat[i,][x]))
  for(j in 1:length(cpt_true)){
    for(b in 1:B){
      set.seed(543+b+i*100+j*12345)
      u_array[i,j,b] = seq(-n, n)[which.min(simu.2BM_Drift(length(y_vec), 0.15, LRV_rkhs_hat_mat[i,j]))]
    }
    CI_array[i,j,] = quantile(u_array[i,j,], probs = c(alpha/2, 1-alpha/2))/kappa2_rkhs_hat_mat[i,j] + cpt_rkhs_LR_new[i,j]
  }
}
sum(floor(CI_array[,1,1]) <= cpt_true[1]-1 & ceiling(CI_array[,1,2]) >= cpt_true[1]-1)/nrow(cpt_rkhs_init_new)
mean(ceiling(CI_array[,1,2]) - floor(CI_array[,1,1]))
sd(ceiling(CI_array[,1,2]) - floor(CI_array[,1,1]))
```


```{r}
set.seed(1400)
r1 = 3
r2 = 3
lambda = 0.0001
ext = 0.1
maxIt = 1
data1 = temp_fragment_data7(mu = 0, r = r1, sigma=1, n = 100, m = 20, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data2 = temp_fragment_data8(mu = 0, r = r2, sigma=1, n = 100, m = 20, sigma_epsilon = 0.01, domain = c(0, 1), delta = 0.6)
data = list("t"= rbind(data1$t, data2$t), "y" = rbind(data1$y, data2$y), "r" = cbind(data1$r, data2$r))
xi_set = c(80)
CV_cpt_result = CV_search_DP_fragment(data$t, data$y, data$r, r = 3, lambda, xi_set, ext, maxIt)
min_idx = which.min(CV_cpt_result$test_error) 
xi_set[min_idx]
cpt_init = unlist(CV_cpt_result$cpt_hat[min_idx])
cpt_init
```



```{r}
refined_eta <- local_refine_fragment(data$t, data$y, data$r, cpt_init,
                                       r=3, lambda = 0.0001, ext = 0.1, maxIt = 1,
                                       w = 0.75)
refined_eta

# estimate jump size
kappa2_list <-  kappa2_fragment(data$t, data$y, data$r, refined_eta, r=3, lambda = 0.0001, ext = 0.1, maxIt = 1)
kappa2 <- kappa2_list$kappa2
kappa2
C <- kappa2_list$C
sigma2_list <- sigma2_fragment(refined_eta, kappa2, C, data$t, data$y, data$r)
sigma_before <- sigma2_list[[1]]
sigma_after <- sigma2_list[[2]]
drift <- omega_fragment(refined_eta, kappa2, C, data$t, data$y, data$r)
  
d <- rep(0,B)
for (b in 1:B) {
    set.seed(100+10*b)
     d[b] <- seq(-nrow(data$y), nrow(data$y))[which.min(simu.2BM_Drift(nrow(data$y), drift, sigma_before, sigma_after))]
}

quantile(d, probs = c(alpha/2, 1-alpha/2))/kappa2
```

```{r}
B=1000
iteration = 100
alpha = 0.01
CI_matrix <- matrix(NaN, nrow = iteration, ncol = 2)
if(length(cpt_init) != 1){
  next
}
else{
  #local refinement
  refined_eta <- local_refine_fragment(data$t, data$y, data$r, cpt_init,
                                       r=3, lambda = 0.0001, ext = 0.1, maxIt = 1,
                                       w = 0.75)
  # estimate jump size
  kappa2_list <-  kappa2_fragment(data$t, data$y, data$r, refined_eta, r=3, lambda = 0.0001, ext = 0.1, maxIt = 1)
  kappa2 <- kappa2_list$kappa2
  C <- kappa2_list$C
  sigma2_list <- sigma2_fragment(refined_eta, kappa2, C, data$t, data$y, data$r)
  sigma_before <- sigma2_list[[1]]
  sigma_after <- sigma2_list[[2]]
  drift <- omega_fragment(refined_eta, kappa2, C, data$t, data$y, data$r)
  
  d <- rep(0,B)
  for (b in 1:B) {
    set.seed(100+10*b)
     d[b] <- seq(-nrow(data$y), nrow(data$y))[which.min(simu.2BM_Drift(nrow(data$y), drift, sigma_before, sigma_after))]
  }
  
   CI_array[i,] = quantile(d, probs = c(alpha/2, 1-alpha/2))/kappa2 + refined_eta
 
}
```











